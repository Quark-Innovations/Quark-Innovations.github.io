<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bus Detector</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#007bff">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the camera view and buttons */
        body {
            font-family: 'Inter', sans-serif;
        }
        #camera-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: auto;
            border-radius: 0.5rem;
            overflow: hidden;
            background-color: #000;
        }
        #camera-view {
            width: 100%;
            display: block;
        }
    </style>

    <!-- This is the favicon that will be visible in the browser tab. -->
    <link rel="icon" type="image/x-icon" href="https://placehold.co/32x32/007bff/ffffff?text=B">
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4">
        <h1 class="text-3xl font-bold text-center mb-4">Bus Detector</h1>

        <div id="camera-container" class="shadow-lg">
            <!-- The video element will remain hidden until camera is turned on -->
            <video id="camera-view" autoplay playsinline class="hidden"></video>
            <div id="camera-placeholder" class="w-full h-64 bg-gray-300 flex items-center justify-center text-gray-600 rounded-md">
                Camera is off. Click "Turn Camera On" to start.
            </div>
        </div>

        <div class="text-center mt-4">
             <button id="toggle-camera-button" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-full">
                Turn Camera On
            </button>
        </div>

        <div id="result-container" class="mt-4 p-4 bg-white rounded-lg shadow-md min-h-[6rem]">
            <h2 class="text-2xl font-semibold mb-2">Status:</h2>
            <p id="result-text">Camera is currently off.</p>
        </div>

        <canvas id="canvas" class="hidden"></canvas>
    </div>

    <script>
        // --- PWA Service Worker Registration ---
        // Registers a service worker for offline capabilities and caching.
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                const swBlob = new Blob([`
                    const CACHE_NAME = 'bus-detector-cache-v1';
                    const urlsToCache = ['/', 'index.html', 'https://cdn.tailwindcss.com'];
                    self.addEventListener('install', e => e.waitUntil(caches.open(CACHE_NAME).then(c => c.addAll(urlsToCache))));
                    self.addEventListener('fetch', e => e.respondWith(caches.match(e.request).then(r => r || fetch(e.request))));
                `], { type: 'application/javascript' });
                const swURL = URL.createObjectURL(swBlob);
                navigator.serviceWorker.register(swURL)
                    .then(reg => console.log('ServiceWorker registration successful with scope: ', reg.scope))
                    .catch(err => console.log('ServiceWorker registration failed: ', err));
            });
        }

        // --- DOM Element References ---
        // Get references to key HTML elements for manipulation.
        const cameraView = document.getElementById('camera-view');
        const cameraPlaceholder = document.getElementById('camera-placeholder'); // New placeholder element
        const toggleCameraButton = document.getElementById('toggle-camera-button');
        const resultContainer = document.getElementById('result-container');
        const resultText = document.getElementById('result-text');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');

        // --- State Management ---
        // Variables to manage the application's state.
        let isCameraOn = false; // Camera is OFF by default
        let detectionInterval = null; // Stores the interval ID for periodic detection.
        let stream = null; // Stores the MediaStream object from the camera.

        // --- Camera Control ---
        // Function to start the camera feed.
        async function startCamera() {
            if (isCameraOn) return; // Prevent starting camera if already on.
            try {
                // IMPORTANT FOR MOBILE DEVICES:
                // Camera access (getUserMedia) typically requires the page to be served over HTTPS.
                // If you are running this code from a local file (file://) or an insecure HTTP server,
                // camera access might be blocked by the browser for security reasons.
                // Also, ensure you grant camera permissions when prompted by your browser.

                // Request access to the user's camera, preferring the environment-facing camera.
                const constraints = { video: { facingMode: 'environment' } };
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                cameraView.srcObject = stream; // Set the video element's source to the camera stream.
                cameraView.classList.remove('hidden'); // Show the video element
                cameraPlaceholder.classList.add('hidden'); // Hide the placeholder
                isCameraOn = true;
                toggleCameraButton.textContent = 'Turn Camera Off';
                toggleCameraButton.classList.replace('bg-green-500', 'bg-red-500');
                toggleCameraButton.classList.replace('hover:bg-green-700', 'hover:bg-red-700');
                resultText.textContent = 'Camera on. Looking for buses...';
                // Start automatic detection every 15 seconds.
                detectionInterval = setInterval(captureAndIdentify, 15000);
                 // Run once immediately after a short delay to allow camera to warm up.
                setTimeout(captureAndIdentify, 1000);
            } catch (err) {
                console.error("Error accessing camera: ", err);
                resultText.textContent = "Could not access the camera. Please grant permission and try again.";
                // Revert button state if camera access fails
                toggleCameraButton.textContent = 'Turn Camera On';
                toggleCameraButton.classList.replace('bg-red-500', 'bg-green-500');
                toggleCameraButton.classList.replace('hover:bg-red-700', 'hover:bg-green-700');
                cameraView.classList.add('hidden'); // Ensure video is hidden
                cameraPlaceholder.classList.remove('hidden'); // Show placeholder
                isCameraOn = false;
            }
        }

        // Function to stop the camera feed.
        function stopCamera() {
            if (!isCameraOn || !stream) return; // Prevent stopping if camera is already off or no stream.
            stream.getTracks().forEach(track => track.stop()); // Stop all tracks in the stream.
            cameraView.srcObject = null; // Clear the video element's source.
            cameraView.classList.add('hidden'); // Hide the video element
            cameraPlaceholder.classList.remove('hidden'); // Show the placeholder
            isCameraOn = false;
            toggleCameraButton.textContent = 'Turn Camera On';
            toggleCameraButton.classList.replace('bg-red-500', 'bg-green-500');
            toggleCameraButton.classList.replace('hover:bg-red-700', 'hover:bg-green-700');
            resultText.textContent = 'Camera is off.';
            // Stop automatic detection interval.
            clearInterval(detectionInterval);
            detectionInterval = null;
        }

        // Event listener for the camera toggle button.
        toggleCameraButton.addEventListener('click', () => {
            if (isCameraOn) {
                stopCamera();
            } else {
                startCamera();
            }
        });

        // --- Image Capture and Analysis ---
        // Captures a frame from the video stream and sends it for identification.
        async function captureAndIdentify() {
            // Ensure camera is on and video is ready before capturing.
            if (!isCameraOn || cameraView.readyState < 2) {
                return; 
            }
            
            resultText.textContent = 'Scanning for bus...';
            // Set canvas dimensions to match video dimensions.
            canvas.width = cameraView.videoWidth;
            canvas.height = cameraView.videoHeight;
            // Draw the current video frame onto the canvas.
            context.drawImage(cameraView, 0, 0, canvas.width, canvas.height);
            // Get the image data as a base64 string (JPEG format).
            const imageData = canvas.toDataURL('image/jpeg').split(',')[1];
            await findBusInImage(imageData); // Send the image data to Gemini API.
        }

        // --- Speech Synthesis Function ---
        // Uses the Web Speech API to speak the given text.
        function speakText(text) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US'; // Set the language for speech.
                speechSynthesis.speak(utterance);
            } else {
                console.warn("Speech Synthesis API not supported in this browser.");
            }
        }

        // --- Gemini API Call for Bus Detection ---
        // Sends the captured image to the Gemini API for bus detection.
        async function findBusInImage(base64ImageData) {
            // IMPORTANT: Leave this API key empty. The Canvas environment will provide it at runtime.
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            // Construct the payload for the Gemini API request.
            const payload = {
                contents: [{
                    parts: [{
                        text: "Analyze the image for a public transport bus. Respond in JSON format. If a bus is visible, set 'bus_detected' to true and extract the bus route number and its destination if they are visible. If no bus is present, set 'bus_detected' to false. Set 'bus_number' and 'destination' to null if not visible."
                    }, {
                        inlineData: {
                            mimeType: "image/jpeg",
                            data: base64ImageData
                        }
                    }]
                }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "bus_detected": { "type": "BOOLEAN" },
                            "bus_number": { "type": "STRING" },
                            "destination": { "type": "STRING" }
                        },
                        required: ["bus_detected"]
                    }
                }
            };

            try {
                // Make the API call to Gemini.
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                const part = data?.candidates?.[0]?.content?.parts?.[0];
                
                if (part && part.text) {
                    const result = JSON.parse(part.text);
                    if (result.bus_detected) {
                        const busNumber = result.bus_number || null;
                        const destination = result.destination || null;
                        let displayText = "Bus is coming!";
                        if(busNumber) {
                           displayText += ` Number: ${busNumber}`;
                        }
                        if(destination) {
                           displayText += ` - Destination: ${destination}`;
                        }
                        if(!busNumber && !destination) {
                            displayText += " (Details not visible)";
                        }
                        resultText.textContent = displayText;
                        speakText(displayText); // Speak the detected information aloud.
                    } else {
                        resultText.textContent = 'No bus detected in the latest scan.';
                        // Optional: Add a sound or speech for "no bus detected" here.
                    }
                } else {
                    resultText.textContent = 'Analysis complete. No bus detected.';
                }

            } catch (error) {
                console.error("Error calling Gemini API:", error);
                resultText.textContent = "An error occurred while calling Gemini.";
            }
        }

        // --- Initialize the app ---
        // No auto-start: Camera is off by default.
        // The button will trigger startCamera() when clicked.

    </script>

    <!-- manifest.json is now created dynamically -->
    <!-- This script dynamically creates and attaches the web app manifest. -->
    <script>
        const manifest = {
            "name": "PWA Bus Detector",
            "short_name": "Bus Detector",
            "start_url": "index.html",
            "display": "standalone",
            "background_color": "#ffffff",
            "theme_color": "#007bff",
            "icons": [
                { "src": "https://placehold.co/192x192/007bff/ffffff?text=Bus", "sizes": "192x192", "type": "image/png" },
                { "src": "https://placehold.co/512x512/007bff/ffffff?text=Bus", "sizes": "512x512", "type": "image/png" }
            ]
        };
        const blob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
        const manifestURL = URL.createObjectURL(blob);
        document.querySelector('link[rel="manifest"]').href = manifestURL;
    </script>

</body>
</html>